<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>JSON Data Editor</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }
    :root {
        --vscode-font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', sans-serif;
        --vscode-foreground: #cccccc;
        --vscode-editor-background: #1e1e1e;
        --vscode-input-background: #3c3c3c;
        --vscode-input-border: #3c3c3c;
        --vscode-button-background: #0e639c;
        --vscode-button-foreground: #ffffff;
        --vscode-focusBorder: #007fd4;
        --vscode-panel-border: #3c3c3c;
        --vscode-tab-activeBackground: #2d2d30;
        --vscode-errorForeground: #f48771;
        --vscode-textLink-foreground: #3794ff;
    }
  
    body {
        font-family: var(--vscode-font-family);
        background-color: var(--vscode-editor-background);
        color: var(--vscode-foreground);
        margin: 0;
        padding: 20px;
        min-height: 100vh;
    }
  
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }

    /* Header Styles */
    .header {
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items: center;
    }

    .header-left {
      display: flex;
      align-items: center;
      gap: 15px;
      margin-right: auto;
    }

    button {
      background-color: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 8px 16px;
      cursor: pointer;
      border-radius: 2px;
      font-size: 13px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
    }

    button:hover {
      background-color: var(--vscode-button-hoverBackground);
    }

    #configBtn {
      background-color: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
    }

    #configBtn:hover {
      background-color: var(--vscode-button-secondaryHoverBackground);
    }

    .schema-info {
      font-size: 12px;
      color: var(--vscode-descriptionForeground);
      padding: 6px 10px;
      background-color: var(--vscode-input-background);
      border-radius: 4px;
      border: 1px solid var(--vscode-input-border);
    }

    /* Tab Styles */
    .tabs-container {
      display: flex;
      flex-direction: column;
      margin-bottom: 20px;
    }

    .tabs-header {
      display: flex;
      gap: 2px;
      border-bottom: 1px solid var(--vscode-panel-border);
      margin-bottom: 20px;
      flex-wrap: wrap;
    }

    .tab-btn {
      background-color: transparent;
      color: var(--vscode-foreground);
      border: none;
      padding: 10px 20px;
      cursor: pointer;
      border-radius: 4px 4px 0 0;
      font-size: 14px;
      position: relative;
      transition: background-color 0.2s;
    }

    .tab-btn:hover {
      background-color: var(--vscode-list-hoverBackground);
    }

    .tab-btn.active {
      background-color: var(--vscode-tab-activeBackground);
      color: var(--vscode-tab-activeForeground);
      border-bottom: 2px solid var(--vscode-focusBorder);
    }

    .tab-btn.active::after {
      content: '';
      position: absolute;
      bottom: -1px;
      left: 0;
      right: 0;
      height: 2px;
      background-color: var(--vscode-focusBorder);
    }

    .tab-content {
      display: none;
      padding: 10px 0;
    }

    .tab-content.active {
      display: block;
      animation: fadeIn 0.3s ease-in-out;
    }

    @keyframes fadeIn {
      from { opacity: 0; }
      to { opacity: 1; }
    }

    .no-tabs-message {
      padding: 40px;
      text-align: center;
      color: var(--vscode-descriptionForeground);
      font-style: italic;
    }

    /* Form Styles */
    .form-group {
      margin-bottom: 15px;
      padding: 15px;
      background-color: var(--vscode-input-background);
      border: 1px solid var(--vscode-input-border);
      border-radius: 4px;
    }

    .form-group label {
      display: block;
      margin-bottom: 5px;
      font-weight: 600;
      font-size: 14px;
    }

    .form-group .description {
      font-size: 12px;
      color: var(--vscode-descriptionForeground);
      margin-bottom: 8px;
    }

    input[type="text"],
    input[type="number"],
    input[type="email"],
    textarea,
    select {
      width: 100%;
      padding: 6px 8px;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border);
      border-radius: 2px;
      font-family: var(--vscode-font-family);
      font-size: 13px;
    }

    input:focus,
    textarea:focus,
    select:focus {
      outline: 1px solid var(--vscode-focusBorder);
    }

    textarea {
      min-height: 80px;
      resize: vertical;
    }

    .checkbox-group {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .checkbox-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .checkbox-item input[type="checkbox"] {
      width: auto;
    }

    .checkbox-item input[type="radio"] {
      width: auto;
    }

    .na-option {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px solid var(--vscode-input-border);
    }

    .na-option label {
      font-style: italic;
      color: var(--vscode-descriptionForeground);
    }

    .multi-select-container {
      position: relative;
      width: 100%;
    }

    .multi-select-trigger {
      width: 100%;
      padding: 6px 8px;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border);
      border-radius: 2px;
      font-family: var(--vscode-font-family);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      min-height: 28px;
    }

    .multi-select-trigger:hover {
      background-color: var(--vscode-dropdown-background);
    }

    .multi-select-trigger::after {
      content: '‚ñº';
      font-size: 10px;
      margin-left: 8px;
    }

    .multi-select-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      background-color: var(--vscode-dropdown-background);
      border: 1px solid var(--vscode-input-border);
      border-top: none;
      max-height: 300px;
      overflow-y: auto;
      z-index: 1000;
      display: none;
      box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
    }

    .multi-select-dropdown.open {
      display: block;
    }

    .multi-select-option {
      padding: 6px 8px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .multi-select-option:hover {
      background-color: var(--vscode-list-hoverBackground);
    }

    .multi-select-option input[type="checkbox"] {
      width: auto;
      margin: 0;
    }

    .multi-select-option.na-option {
      border-top: 1px solid var(--vscode-input-border);
      font-style: italic;
      color: var(--vscode-descriptionForeground);
    }

    .multi-select-selected {
      display: flex;
      flex-wrap: wrap;
      gap: 4px;
      min-height: 20px;
    }

    .multi-select-tag {
      background-color: var(--vscode-badge-background);
      color: var(--vscode-badge-foreground);
      padding: 2px 6px;
      border-radius: 3px;
      font-size: 12px;
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }

    .multi-select-placeholder {
      color: var(--vscode-input-placeholderForeground);
    }

    .form-group.disabled {
      opacity: 0.5;
      pointer-events: none;
    }

    .form-group.disabled input,
    .form-group.disabled select,
    .form-group.disabled textarea,
    .form-group.disabled .multi-select-container {
      background-color: var(--vscode-input-background);
      cursor: not-allowed;
    }

    .disabled-indicator {
      font-size: 11px;
      color: var(--vscode-descriptionForeground);
      font-style: italic;
      margin-top: 4px;
    }

    .required::after {
      content: " *";
      color: var(--vscode-errorForeground);
    }

    .no-schema {
      text-align: center;
      padding: 60px 20px;
      color: var(--vscode-descriptionForeground);
    }

    #editor-form {
      display: none;
    }

    #editor-form.active {
      display: block;
    }

    /* Nested Object Styles */
    .nested-object {
      margin-left: 0;
      padding: 15px;
      border-left: 3px solid var(--vscode-textLink-foreground);
      background-color: var(--vscode-editor-background);
      margin-top: 10px;
    }

    .nested-object-header {
      font-weight: 600;
      font-size: 15px;
      margin-bottom: 15px;
      color: var(--vscode-textLink-foreground);
      display: flex;
      align-items: center;
      gap: 8px;
      cursor: pointer;
      user-select: none;
    }

    .nested-object-header::before {
      content: '‚ñº';
      font-size: 10px;
      transition: transform 0.2s;
    }

    .nested-object-header.collapsed::before {
      transform: rotate(-90deg);
    }

    .nested-object-content {
      display: block;
    }

    .nested-object-content.collapsed {
      display: none;
    }

    /* Array Styles */
    .array-container {
      border: 1px solid var(--vscode-input-border);
      padding: 10px;
      border-radius: 4px;
      margin-top: 8px;
    }

    .array-item {
      margin-bottom: 15px;
      padding: 15px;
      background-color: var(--vscode-editor-background);
      border: 1px solid var(--vscode-input-border);
      border-radius: 4px;
      position: relative;
    }

    .array-item-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px solid var(--vscode-input-border);
    }

    .array-item-title {
      font-weight: 600;
      color: var(--vscode-textLink-foreground);
    }

    .array-controls {
      display: flex;
      gap: 5px;
      margin-top: 10px;
    }

    .array-controls button {
      padding: 6px 12px;
      font-size: 12px;
    }

    .remove-item-btn {
      background-color: var(--vscode-errorForeground);
      padding: 4px 8px;
      font-size: 11px;
    }

    .remove-item-btn:hover {
      opacity: 0.8;
    }

    /* Error & Validation Styles */
    .error-message {
      color: var(--vscode-errorForeground);
      font-size: 12px;
      margin-top: 4px;
      display: none;
    }

    .has-error {
      border-color: var(--vscode-errorForeground) !important;
    }

    .validation-error {
      color: var(--vscode-errorForeground);
      background-color: var(--vscode-inputValidation-errorBackground);
      border: 1px solid var(--vscode-inputValidation-errorBorder);
      padding: 10px;
      margin: 10px 0;
      border-radius: 4px;
      display: none;
    }

    /* Date Input Styles */
    input[type="date"] {
      width: 100%;
      padding: 6px 8px;
      background-color: var(--vscode-input-background);
      color: var(--vscode-input-foreground);
      border: 1px solid var(--vscode-input-border);
      border-radius: 2px;
      font-family: var(--vscode-font-family);
      font-size: 13px;
      cursor: pointer;
    }

    input[type="date"]::-webkit-calendar-picker-indicator {
      filter: invert(0.5);
      cursor: pointer;
    }

    input[type="date"]:focus {
      outline: 1px solid var(--vscode-focusBorder);
    }

    /* Status Bar Styles */
    .status-bar {
      margin-top: 20px;
      padding: 10px;
      background-color: var(--vscode-statusBar-background);
      color: var(--vscode-statusBar-foreground);
      border-radius: 4px;
      font-size: 12px;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .status-info {
      display: flex;
      gap: 15px;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .status-icon {
      font-size: 14px;
    }

    .loading {
      display: inline-block;
      width: 12px;
      height: 12px;
      border: 2px solid var(--vscode-progressBar-background);
      border-top: 2px solid transparent;
      border-radius: 50%;
      animation: spin 1s linear infinite;
    }

    /* ============ INVALID DATA STYLES ============ */
    select.invalid-data,
    input.invalid-data,
    textarea.invalid-data,
    .multi-select-container.invalid-data .multi-select-trigger {
      border-color: var(--vscode-errorForeground);
      animation: pulse-border 2s ease-in-out infinite;
    }

    @keyframes pulse-border {
      0%, 100% { border-color: var(--vscode-errorForeground); }
      50% { border-color: #ff6b6b; }
    }

    /* When user starts interacting with invalid field */
    select.invalid-data:focus,
    input.invalid-data:focus,
    textarea.invalid-data:focus,
    .multi-select-container.invalid-data .multi-select-trigger:focus {
      animation: none;
    }

    /* Make form groups with invalid data stand out */
    .form-group:has(.invalid-data) {
      background-color: rgba(220, 53, 69, 0.05);
      border-left: 3px solid var(--vscode-errorForeground);
    }

    /* Tooltip for invalid fields */
    .invalid-tooltip {
      display: none;
      position: absolute;
      background-color: var(--vscode-errorForeground);
      color: white;
      padding: 4px 8px;
      border-radius: 4px;
      font-size: 12px;
      z-index: 10000;
      white-space: nowrap;
      pointer-events: none;
    }

    /* Invalid fields summary */
    .invalid-fields-summary {
      position: sticky;
      top: 0;
      background-color: rgba(220, 53, 69, 0.1);
      border: 2px solid var(--vscode-errorForeground);
      border-radius: 4px;
      padding: 16px;
      margin-bottom: 20px;
      z-index: 1000;
    }

    .invalid-fields-summary h3 {
      margin: 0 0 12px 0;
      color: var(--vscode-errorForeground);
      font-size: 16px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .invalid-fields-summary ul {
      margin: 0;
      padding-left: 20px;
      color: var(--vscode-errorForeground);
    }

    .invalid-fields-summary li {
      margin-bottom: 6px;
      font-size: 14px;
      cursor: pointer;
    }

    .invalid-fields-summary li:hover {
      text-decoration: underline;
    }

    .invalid-fields-summary .close-summary {
      float: right;
      background: none;
      border: none;
      font-size: 20px;
      cursor: pointer;
      color: var(--vscode-errorForeground);
      padding: 0;
      width: 24px;
      height: 24px;
      line-height: 1;
    }

    .invalid-fields-summary .close-summary:hover {
      opacity: 0.8;
    }

    /* Status indicator for invalid fields */
    .invalid-status-indicator {
      font-size: 11px;
      color: var(--vscode-errorForeground);
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .invalid-status-indicator::before {
      content: "‚ö†Ô∏è";
      font-size: 10px;
    }

  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <div class="header-left">
        <button id="configBtn" title="Change schema/choices configuration">
          <span style="font-size: 14px;">‚öôÔ∏è</span> Config
        </button>
        <div class="schema-info">
          Schema: <span id="schema-name">No Schema Loaded</span>
        </div>
      </div>
      
      <button id="loadDataBtn">
        <span style="font-size: 14px;">üìÇ</span> Load Data
      </button>
      <button id="saveBtn">
        <span style="font-size: 14px;">üíæ</span> Save
      </button>
      <button id="exportBtn">
        <span style="font-size: 14px;">üìã</span> Copy
      </button>
    </div>
    
    <!-- Tabs Container -->
    <div id="tabs-container" class="tabs-container" style="display: none;">
      <div class="tabs-header" id="tabs-header"></div>
      <div id="tabs-content" class="tabs-content"></div>
    </div>
    
    <!-- Main Content (no tabs) -->
    <div id="no-schema" class="no-schema">
      <h2>No Schema Loaded</h2>
      <p>Click "Config" to load a schema file</p>
    </div>
    
    <div id="editor-form"></div>
  </div>

  <script>
    // ============ GLOBAL VARIABLES ============
    let currentSchema = null;
    let customChoices = {};
    let initialData = {};
    let definitions = {};
    let conditionalRules = {};
    let formData = {};
    let fieldDependencies = {};

    // ============ DOM ELEMENTS ============
    const vscode = acquireVsCodeApi();
    const configBtn = document.getElementById('configBtn');
    const loadDataBtn = document.getElementById('loadDataBtn');
    const saveBtn = document.getElementById('saveBtn');
    const exportBtn = document.getElementById('exportBtn');
    const tabsContainer = document.getElementById('tabs-container');
    const tabsHeader = document.getElementById('tabs-header');
    const tabsContent = document.getElementById('tabs-content');
    const noSchemaDiv = document.getElementById('no-schema');
    const editorForm = document.getElementById('editor-form');
    const schemaNameEl = document.getElementById('schema-name');

    // ============ INITIALIZATION ============
    document.addEventListener('DOMContentLoaded', function() {
      console.log('DOM loaded, initializing...');
      
      if (window.currentSchema) {
        console.log('Initial schema injected');
        handleSchemaUpdate({
          schema: window.currentSchema,
          choices: window.customChoices || {},
          definitions: window.definitions || {},
          conditionalRules: window.conditionalRules || {}
        });
      } else {
        console.log('No initial schema injected');
        updateSchemaDisplay();
      }
      
      if (window.initialData && Object.keys(window.initialData).length > 0) {
        console.log('Initial data injected');
        initialData = window.initialData;
      }
    });

    // ============ EVENT LISTENERS ============
    if (configBtn) {
      configBtn.addEventListener('click', () => {
        vscode.postMessage({ command: 'openConfig' });
      });
    }

    if (loadDataBtn) {
      loadDataBtn.addEventListener('click', () => {
        vscode.postMessage({ command: 'loadData' });
      });
    }
    
    if (saveBtn) {
      saveBtn.addEventListener('click', () => {
        const data = collectFormData();
        vscode.postMessage({ command: 'saveJson', data: data });
      });
    }
    
    if (exportBtn) {
      exportBtn.addEventListener('click', () => {
        const data = collectFormData();
        vscode.postMessage({ command: 'exportJson', data: data });
      });
    }

    window.addEventListener('message', event => {
      const message = event.data;
      console.log('Message received:', message.command);
      
      switch (message.command) {
        case 'updateSchema':
          handleSchemaUpdate(message);
          break;
        case 'dataLoaded':
          handleDataLoaded(message);
          break;
        case 'reloadForm':
          resetUI();
          break;
        case 'showNotification':
          showNotification(message.text);
          break;
      }
    });

    // ============ UI MANAGEMENT FUNCTIONS ============
    function updateSchemaDisplay() {
      if (schemaNameEl) {
        if (currentSchema && currentSchema.title) {
          schemaNameEl.textContent = currentSchema.title;
        } else if (currentSchema) {
          schemaNameEl.textContent = 'Loaded Schema';
        } else {
          schemaNameEl.textContent = 'No Schema Loaded';
        }
      }
    }

    function clearUI() {
      console.log('Clearing UI');
      
      // Clear invalid fields tracking
      invalidFields.clear();

      if (tabsHeader) tabsHeader.innerHTML = '';
      if (tabsContent) tabsContent.innerHTML = '';
      if (tabsContainer) tabsContainer.style.display = 'none';
      
      if (editorForm) {
        editorForm.innerHTML = '';
        editorForm.classList.remove('active');
        editorForm.style.display = 'none';
      }
      
      if (noSchemaDiv) {
        noSchemaDiv.style.display = 'block';
      }
    }

    function resetUI() {
      console.log('Resetting UI');
      updateSchemaDisplay();
      clearUI();
      initializeDependencies();
      
      if (currentSchema) {
        renderForm(currentSchema);
        
        if (initialData && Object.keys(initialData).length > 0) {
          setTimeout(() => {
            populateFormWithData(initialData);
            console.log('Form populated with initial data');
            setupDependencyListeners();
          }, 500);
        } else {
          setTimeout(() => {
            setupDependencyListeners();
          }, 500);
        }
      } else {
        console.log('No schema to render');
      }
    }

    function showNotification(message) {
      console.log('Notification:', message);
    }

    // ============ MESSAGE HANDLERS ============
    function handleSchemaUpdate(message) {
      console.log('Updating schema with new data');
      
      if (message.schema) {
        currentSchema = message.schema;
        console.log('Schema updated:', currentSchema.title || 'Untitled');
      }
      
      if (message.choices) {
        customChoices = message.choices;
        console.log('Choices updated:', Object.keys(customChoices).length, 'fields');
      }
      
      if (message.definitions) {
        definitions = message.definitions;
        console.log('Definitions updated');
      }
      
      if (message.conditionalRules) {
        conditionalRules = message.conditionalRules;
        console.log('Conditional rules updated');
      }
      
      initialData = {};
      formData = {};
      resetUI();
    }

    function handleDataLoaded(message) {
      console.log('Loading data into form');
      
      if (message.data) {
        initialData = message.data;
        console.log('Data loaded:', Object.keys(initialData).length, 'root keys');
        
        if (currentSchema) {
          setTimeout(() => {
            populateFormWithData(initialData);
            showNotification(`Data loaded. Found ${invalidFields.size} field(s) with invalid values.`);
          }, 300);
        } else {
          console.warn('Cannot load data: No schema loaded');
        }
      }
    }

    // ============ FORM RENDERING FUNCTIONS ============
    function renderForm(schema) {
      console.log('Rendering form with schema:', schema.title || 'Untitled');
      
      if (noSchemaDiv) {
        noSchemaDiv.style.display = 'none';
      }

      const properties = schema.properties || {};
      const required = schema.required || [];
      const rootKeys = Object.keys(properties);
      
      console.log('Root keys found:', rootKeys);
      
      const shouldUseTabs = rootKeys.length > 1;
      
      if (shouldUseTabs) {
        console.log('Using tabbed interface for', rootKeys.length, 'root keys');
        renderTabsInterface(rootKeys, properties, required);
      } else {
        console.log('Using regular form interface');
        renderRegularForm(rootKeys, properties, required);
      }
    }
    
    function renderTabsInterface(rootKeys, properties, required) {
      tabsContainer.style.display = 'flex';
      editorForm.style.display = 'none';
      
      tabsHeader.innerHTML = '';
      tabsContent.innerHTML = '';
      
      rootKeys.forEach((key, index) => {
        const prop = properties[key];
        const title = prop.title || key;
        
        const tabBtn = document.createElement('button');
        tabBtn.className = 'tab-btn' + (index === 0 ? ' active' : '');
        tabBtn.textContent = title;
        tabBtn.dataset.tabKey = key;
        tabBtn.addEventListener('click', () => switchTab(key));
        tabsHeader.appendChild(tabBtn);
        
        const tabContent = document.createElement('div');
        tabContent.className = 'tab-content' + (index === 0 ? ' active' : '');
        tabContent.id = 'tab-' + key;
        tabContent.dataset.tabKey = key;
        
        const isRequired = required.includes(key);
        const fieldHtml = createField(key, prop, isRequired, [key]);
        const div = document.createElement('div');
        div.innerHTML = fieldHtml;
        tabContent.appendChild(div.firstElementChild);
        
        tabsContent.appendChild(tabContent);
      });
      
      if (rootKeys.length > 0) {
        attachEventListenersToTab(rootKeys[0]);
      }
    }
    
    function renderRegularForm(rootKeys, properties, required) {
      tabsContainer.style.display = 'none';
      editorForm.style.display = 'block';
      editorForm.classList.add('active');
      
      if (rootKeys.length === 1) {
        const [key] = rootKeys;
        const prop = properties[key];
        const isRequired = required.includes(key);
        const fieldHtml = createField(key, prop, isRequired, [key]);
        const div = document.createElement('div');
        div.innerHTML = fieldHtml;
        editorForm.appendChild(div.firstElementChild);
      } else if (rootKeys.length > 0) {
        rootKeys.forEach(key => {
          const prop = properties[key];
          const isRequired = required.includes(key);
          const fieldHtml = createField(key, prop, isRequired, [key]);
          const div = document.createElement('div');
          div.innerHTML = fieldHtml;
          editorForm.appendChild(div.firstElementChild);
        });
      } else {
        const noTabsMessage = document.createElement('div');
        noTabsMessage.className = 'no-tabs-message';
        noTabsMessage.textContent = 'No properties found in schema';
        editorForm.appendChild(noTabsMessage);
      }
      
      attachEventListeners();
    }
    
    function switchTab(tabKey) {
      console.log('Switching to tab:', tabKey);
      
      document.querySelectorAll('.tab-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tabKey === tabKey);
      });
      
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.toggle('active', content.dataset.tabKey === tabKey);
      });
      
      attachEventListenersToTab(tabKey);
    }

    // ============ FIELD CREATION FUNCTIONS ============
    function resolveRef(ref) {
      if (!ref || !ref.startsWith('#/')) return null;
      const path = ref.substring(2).split('/');
      let result = currentSchema;
      for (const key of path) {
        result = result[key];
        if (!result) return null;
      }
      return result;
    }
      
    function createField(key, prop, isRequired, path) {
      if (prop.$ref) {
        prop = resolveRef(prop.$ref);
        if (!prop) return '';
      }

      const type = prop.type;
      const title = prop.title || key;
      const description = prop.description || '';
      const pathStr = path.join('.');
      
      if (type === 'object' && prop.properties) {
        return createNestedObject(key, prop, isRequired, path);
      }
      
      if (type === 'array') {
        const items = prop.items;
        if (items && (items.type === 'object' || items.$ref)) {
          return createArrayOfObjects(key, prop, isRequired, path);
        }
      }

      const choiceConfig = getDynamicValues(pathStr);
      
      let enumValues = [];
      let responseType = null;
      let hasNAOption = false;
      let naValue = null;
      
      if (choiceConfig && typeof choiceConfig === 'object' && !Array.isArray(choiceConfig)) {
        let rawValues = choiceConfig.values || [];
        
        enumValues = [];
        rawValues.forEach(val => {
          if (typeof val === 'string' && val.includes('-')) {
            const rangeMatch = val.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) {
              const start = parseInt(rangeMatch[1]);
              const end = parseInt(rangeMatch[2]);
              if (start <= end) {
                for (let i = start; i <= end; i++) {
                  enumValues.push(i);
                }
              }
            } else {
              enumValues.push(val);
            }
          } else {
            enumValues.push(val);
          }
        });
        
        responseType = choiceConfig.response_type || null;
        naValue = choiceConfig.na || null;
        hasNAOption = naValue !== null;
      } else if (Array.isArray(choiceConfig)) {
        enumValues = choiceConfig;
        responseType = type === 'array' ? 'multi-select' : 'single-select';
      } else {
        enumValues = prop.enum || [];
        responseType = type === 'array' ? 'multi-select' : 'single-select';
      }
      
      let inputHtml = '';

      if (enumValues.length > 0) {
        if (responseType === 'multi-select') {
          inputHtml = createMultiSelectInput(pathStr, enumValues, hasNAOption, naValue);
        } else if (responseType === 'single-select') {
          inputHtml = createSingleSelectInput(pathStr, enumValues, hasNAOption, naValue);
        }
      } else {
        inputHtml = createBasicInput(type, pathStr, prop, isRequired);
      }

      return `
        <div class="form-group" data-field-path="${pathStr}">
          <label class="${isRequired ? 'required' : ''}">${title}</label>
          ${description ? `<div class="description">${description}</div>` : ''}
          ${inputHtml}
        </div>
      `;
    }

    function createMultiSelectInput(pathStr, enumValues, hasNAOption, naValue) {
      const dropdownId = 'multiselect_' + pathStr.replace(/\./g, '_');
      let html = `
        <div class="multi-select-container" id="${dropdownId}">
          <div class="multi-select-trigger" onclick="toggleMultiSelectDropdown('${dropdownId}')" tabindex="0">
            <div class="multi-select-selected" id="${dropdownId}_selected">
              <span class="multi-select-placeholder">-- Select --</span>
            </div>
          </div>
          <div class="multi-select-dropdown" id="${dropdownId}_dropdown">
      `;
      
      enumValues.forEach((val, idx) => {
        html += `
          <div class="multi-select-option">
            <input type="checkbox" 
              id="${pathStr}_${idx}" 
              value="${val}" 
              data-path="${pathStr}"
              data-dropdown="${dropdownId}"
              class="multi-select-checkbox"
              onchange="handleMultiSelectChange('${pathStr}', '${dropdownId}')">
            <label for="${pathStr}_${idx}">${val}</label>
          </div>
        `;
      });
      
      if (hasNAOption) {
        html += `
          <div class="multi-select-option na-option">
            <input type="checkbox" 
              id="${pathStr}_na" 
              value="${naValue}" 
              data-path="${pathStr}"
              data-dropdown="${dropdownId}"
              class="na-checkbox"
              onchange="handleNAChange('${pathStr}', '${dropdownId}')">
            <label for="${pathStr}_na">${naValue} (exclusive)</label>
          </div>
        `;
      }
      
      html += `
          </div>
        </div>
      `;
      
      return html;
    }

    function createSingleSelectInput(pathStr, enumValues, hasNAOption, naValue) {
      let html = `<select name="${pathStr}" id="${pathStr}" data-path="${pathStr}">
        <option value="">-- Select --</option>
        ${enumValues.map(val => `<option value="${val}">${val}</option>`).join('')}`;
      
      if (hasNAOption) {
        html += `<option value="${naValue}">${naValue}</option>`;
      }
      
      html += `</select>`;
      return html;
    }

    function createBasicInput(type, pathStr, prop, isRequired) {
      switch (type) {
        case 'string':
          if (prop.format === 'date') {
            const minDate = prop.minimum || '1930-01-01';
            const maxDate = prop.maximum || new Date().toISOString().split('T')[0];
            return `<input type="date" name="${pathStr}" id="${pathStr}" data-path="${pathStr}" min="${minDate}" max="${maxDate}" ${isRequired ? 'required' : ''}>`;
          } else if (prop.format === 'email') {
            return `<input type="email" name="${pathStr}" id="${pathStr}" data-path="${pathStr}" ${isRequired ? 'required' : ''}>`;
          } else if (prop.maxLength && prop.maxLength > 100) {
            return `<textarea name="${pathStr}" id="${pathStr}" data-path="${pathStr}" ${isRequired ? 'required' : ''}></textarea>`;
          } else {
            return `<input type="text" name="${pathStr}" id="${pathStr}" data-path="${pathStr}" ${isRequired ? 'required' : ''}>`;
          }
        case 'integer':
        case 'number':
          return `<input type="number" name="${pathStr}" id="${pathStr}" data-path="${pathStr}"
            ${prop.minimum !== undefined ? `min="${prop.minimum}"` : ''}
            ${prop.maximum !== undefined ? `max="${prop.maximum}"` : ''}
            ${isRequired ? 'required' : ''}>`;
        case 'boolean':
          return `<input type="checkbox" name="${pathStr}" id="${pathStr}" data-path="${pathStr}">`;
        case 'array':
          return `<textarea name="${pathStr}" id="${pathStr}" data-path="${pathStr}" placeholder="Enter comma-separated values"></textarea>`;
        default:
          return `<input type="text" name="${pathStr}" id="${pathStr}" data-path="${pathStr}" ${isRequired ? 'required' : ''}>`;
      }
    }

    function createNestedObject(key, prop, isRequired, path) {
      const title = prop.title || key;
      const description = prop.description || '';
      const pathStr = path.join('.');
      const properties = prop.properties || {};
      const required = prop.required || [];
      
      let fieldsHtml = '';
      for (const [subKey, subProp] of Object.entries(properties)) {
        const isSubRequired = required.includes(subKey);
        fieldsHtml += createField(subKey, subProp, isSubRequired, [...path, subKey]);
      }

      return `
        <div class="form-group" data-field-path="${pathStr}">
          <div class="nested-object">
            <div class="nested-object-header" onclick="toggleNested(this)">
              <span>${title}</span>
              ${isRequired ? '<span style="color: var(--vscode-errorForeground)">*</span>' : ''}
            </div>
            ${description ? `<div class="description">${description}</div>` : ''}
            <div class="nested-object-content">
              ${fieldsHtml}
            </div>
          </div>
        </div>
      `;
    }

    function createArrayOfObjects(key, prop, isRequired, path) {
      const title = prop.title || key;
      const description = prop.description || '';
      const pathStr = path.join('.');
      
      return `
        <div class="form-group" data-field-path="${pathStr}">
          <label class="${isRequired ? 'required' : ''}">${title}</label>
          ${description ? `<div class="description">${description}</div>` : ''}
          <div class="array-container" id="array_${pathStr}" data-path="${pathStr}">
            <div class="array-controls">
              <button onclick="addArrayItem('${pathStr}', ${JSON.stringify(prop.items).replace(/"/g, '&quot;')})">Add Item</button>
            </div>
          </div>
        </div>
      `;
    }

    // ============ FORM DATA COLLECTION FUNCTIONS ============
    function collectFormData() {
      const data = {};
      
      if (tabsContainer.style.display !== 'none') {
        const tabContents = document.querySelectorAll('.tab-content');
        tabContents.forEach(tabContent => {
          const inputs = tabContent.querySelectorAll('[data-path]');
          processInputsForDataCollection(inputs, data);
        });
      } else {
        const inputs = document.querySelectorAll('[data-path]');
        processInputsForDataCollection(inputs, data);
      }
      
      console.log('Collected form data:', data);
      return data;
    }
    
    function processInputsForDataCollection(inputs, data) {
      const processedPaths = new Set();
      
      inputs.forEach(input => {
        const path = input.dataset.path;
        if (!path || processedPaths.has(path)) return;
        
        if (input.classList && input.classList.contains('na-checkbox')) {
          const naCheckbox = document.getElementById(path + '_na');
          if (naCheckbox && naCheckbox.checked) {
            setNestedValue(data, path, naCheckbox.value);
            processedPaths.add(path);
          }
        }
        else if (input.classList && input.classList.contains('multi-select-checkbox')) {
          if (!processedPaths.has(path)) {
            const naCheckbox = document.getElementById(path + '_na');
            if (naCheckbox && naCheckbox.checked) {
              setNestedValue(data, path, naCheckbox.value);
            } else {
              const checkboxes = document.querySelectorAll(`[data-path="${path}"].multi-select-checkbox:checked`);
              if (checkboxes.length > 0) {
                setNestedValue(data, path, Array.from(checkboxes).map(cb => cb.value));
              } else {
                setNestedValue(data, path, []);
              }
            }
            processedPaths.add(path);
          }
        }
        else if (input.type === 'checkbox' && !input.classList.contains('na-checkbox') && !input.classList.contains('multi-select-checkbox')) {
          setNestedValue(data, path, input.checked);
          processedPaths.add(path);
        }
        else if (input.type === 'number') {
          setNestedValue(data, path, input.value ? Number(input.value) : null);
          processedPaths.add(path);
        }
        else if (input.type === 'date'){
          setNestedValue(data, path, input.value || null);
          processedPaths.add(path);
        }
        else if (input.tagName === 'TEXTAREA' && input.placeholder && input.placeholder.includes('comma-separated')) {
          const value = input.value.trim() ? input.value.split(',').map(v => v.trim()).filter(v => v) : [];
          setNestedValue(data, path, value);
          processedPaths.add(path);
        }
        else if (input.tagName === 'SELECT' || (input.tagName === 'INPUT' && input.type === 'text') || (input.tagName === 'INPUT' && input.type === 'email') || input.tagName === 'TEXTAREA') {
          setNestedValue(data, path, input.value);
          processedPaths.add(path);
        }
      });
    }

    function setNestedValue(obj, path, value) {
      const keys = path.split('.');
      let current = obj;
      
      for (let i = 0; i < keys.length - 1; i++) {
        const key = keys[i];
        const nextKey = keys[i + 1];
        
        if (!isNaN(nextKey)) {
          if (!current[key]) current[key] = [];
          if (!current[key][nextKey]) current[key][nextKey] = {};
          current = current[key][nextKey];
          i++;
        } else {
          if (!current[key]) current[key] = {};
          current = current[key];
        }
      }
      
      current[keys[keys.length - 1]] = value;
    }

    // ============ FORM POPULATION FUNCTIONS ============
    function populateFormWithData(data) {
      console.log('Populating form with data:', data);

      // clear previous invalid fields
      invalidFields.clear();

      // first populate the form
      populateFields(data, []);

      // then validate all populated data
      
      setTimeout(() => {
        validateLoadedData(data);
        initializeDependencies();
        
        for (const [fieldKey] of Object.entries(customChoices)) {
          if (customChoices[fieldKey] && customChoices[fieldKey].dependent_values) {
            refreshFieldWithDependencies(fieldKey);
          }
        }
        
        applyConditionalRules();
        setupDependencyListeners();
      }, 300);
    }

    function populateFields(data, parentPath) {
      for (const [key, value] of Object.entries(data)) {
        const currentPath = [...parentPath, key];
        const pathStr = currentPath.join('.');
        
        if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
          populateFields(value, currentPath);
        } else if (Array.isArray(value)) {
          if (value.length > 0 && typeof value[0] === 'object' && value[0] !== null) {
            populateArrayOfObjects(pathStr, value);
          } else {
            populateArrayField(pathStr, value);
          }
        } else {
          populateSingleField(pathStr, value);
        }
      }
    }

    function populateSingleField(pathStr, value) {
      if (value === null || value === undefined) {
        console.log(`Skipping null/undefined value for ${pathStr}`);
        return;
      }
      
      const escapedPath = pathStr.replace(/\./g, '_');
      let container = document.getElementById(`multiselect_${escapedPath}`);
      
      // Look for multi-select container
      if (!container) {
        const containers = document.querySelectorAll('.multi-select-container');
        for (const cont of containers) {
          const firstCheckbox = cont.querySelector('[data-path]');
          if (firstCheckbox && firstCheckbox.dataset.path === pathStr) {
            container = cont;
            break;
          }
        }
      }
      
      // Handle multi-select fields
      if (container) {
        populateArrayField(pathStr, value);
        
        // Validate after populating (with delay to ensure DOM is updated)
        setTimeout(() => {
          if (!isValidValueForField(pathStr, value)) {
            markFieldAsInvalid(pathStr, value);
          }
        }, 150);
        
        return;
      }
      
      // Handle single-select dropdowns
      let input = document.querySelector(`select[data-path="${pathStr}"]`);
      if (input) {
        // Check for special string values that should be allowed
        const isSpecialStringValue = value === 'N/A' || value === 'Unknown/Unsure' || 
                                    value === 'None of the listed options';
        
        // Check if value exists in dropdown options
        const optionExists = Array.from(input.options).some(option => {
          // Handle special N/A values
          if (isSpecialStringValue && option.value === value) {
            return true;
          }
          return option.value === value;
        });
        
        if (optionExists) {
          input.value = value;
          input.dispatchEvent(new Event('change'));
          
          // Validate after setting value (special values are always valid)
          setTimeout(() => {
            if (!isSpecialStringValue && !isValidValueForField(pathStr, value)) {
              markFieldAsInvalid(pathStr, value);
            }
          }, 50);
        } else {
          console.warn(`Value "${value}" not found in dropdown options for ${pathStr}`);
          
          // Set the value anyway (might be a text input styled as dropdown)
          input.value = value;
          input.dispatchEvent(new Event('change'));
          
          // Mark as invalid since value not in options (unless it's a special numeric value)
          const isSpecialNumericValue = value === -9999 || value === -8888 || 
                                      value === '-9999' || value === '-8888';
          if (!isSpecialStringValue && !isSpecialNumericValue) {
            markFieldAsInvalid(pathStr, value);
          }
        }
        return;
      }
      
      // Handle text inputs
      input = document.querySelector(`input[type="text"][data-path="${pathStr}"], input[type="email"][data-path="${pathStr}"]`);
      if (input) {
        input.value = value;
        input.dispatchEvent(new Event('change'));
        
        // Validate text inputs (check if they should be dropdowns)
        setTimeout(() => {
          // Check if this field has choices defined
          const choiceConfig = getDynamicValues(pathStr);
          if (choiceConfig && choiceConfig.values && choiceConfig.values.length > 0) {
            // Special string values are always valid
            if (value === 'N/A' || value === 'Unknown/Unsure' || value === 'None of the listed options') {
              return; // Valid special value
            }
            
            // This should be a dropdown, not a text input
            if (!isValidValueForField(pathStr, value)) {
              markFieldAsInvalid(pathStr, value);
            }
          }
        }, 50);
        
        return;
      }
      
      // Handle number inputs
      input = document.querySelector(`input[type="number"][data-path="${pathStr}"]`);
      if (input) {
        // Convert value to number if it's a string
        const numValue = typeof value === 'string' ? Number(value) : value;
        input.value = numValue;
        input.dispatchEvent(new Event('change'));
        
        // Validate numeric values
        setTimeout(() => {
          const choiceConfig = getDynamicValues(pathStr);
          if (choiceConfig && choiceConfig.values && choiceConfig.values.length > 0) {
            // Special numeric values are always valid
            if (numValue === -9999 || numValue === -8888) {
              return; // Valid special value
            }
            
            // Check if number is valid according to choices
            if (!isValidValueForField(pathStr, numValue)) {
              markFieldAsInvalid(pathStr, value);
            }
          }
        }, 50);
        
        return;
      }
      
      // Handle date inputs
      input = document.querySelector(`input[type="date"][data-path="${pathStr}"]`);
      if (input) {
        input.value = value;
        input.dispatchEvent(new Event('change'));
        return;
      }
      
      // Handle checkboxes (non-multi-select)
      input = document.querySelector(`input[type="checkbox"][data-path="${pathStr}"]:not(.multi-select-checkbox):not(.na-checkbox)`);
      if (input) {
        // Convert various boolean representations
        let boolValue;
        if (value === true || value === 'true' || value === 'Yes' || value === 1) {
          boolValue = true;
        } else if (value === false || value === 'false' || value === 'No' || value === 0) {
          boolValue = false;
        } else {
          boolValue = Boolean(value);
        }
        
        input.checked = boolValue;
        input.dispatchEvent(new Event('change'));
        
        // Validate checkbox values
        setTimeout(() => {
          const choiceConfig = getDynamicValues(pathStr);
          if (choiceConfig && choiceConfig.values) {
            const validBoolValues = ['Yes', 'No', 'true', 'false', true, false, 'I Quit'];
            const isValid = validBoolValues.includes(value) || 
                          choiceConfig.values.includes(value.toString());
            
            if (!isValid) {
              markFieldAsInvalid(pathStr, value);
            }
          }
        }, 50);
        
        return;
      }
      
      // Handle textareas
      input = document.querySelector(`textarea[data-path="${pathStr}"]`);
      if (input) {
        if (Array.isArray(value)) {
          input.value = value.join(', ');
        } else {
          input.value = value;
        }
        input.dispatchEvent(new Event('change'));
        return;
      }
      
      // If we get here, we couldn't find the input
      console.warn(`Could not find input for path: ${pathStr}`);
      
      // Still validate the value if we have choices for this field
      setTimeout(() => {
        const choiceConfig = getDynamicValues(pathStr);
        if (choiceConfig && choiceConfig.values && choiceConfig.values.length > 0) {
          // Check for special values first
          if (value === 'N/A' || value === 'Unknown/Unsure' || value === 'None of the listed options' ||
              value === -9999 || value === -8888 || value === '-9999' || value === '-8888') {
            return; // Special values are always valid
          }
          
          if (!isValidValueForField(pathStr, value)) {
            // Mark as invalid even though we couldn't find the element
            console.warn(`Value "${value}" is invalid for field ${pathStr} but element not found`);
          }
        }
      }, 100);
    }

    function populateArrayField(pathStr, values) {
      console.log(`Populating array field: ${pathStr} with values:`, values);
      
      // Helper function to update multi-select display
      function updateMultiSelectDisplayLocal(dropdownId, path) {
        const selectedContainer = document.getElementById(dropdownId + '_selected');
        if (!selectedContainer) return;
        
        const naCheckbox = document.getElementById(path + '_na');
        const selectedCheckboxes = document.querySelectorAll(`[data-path="${path}"].multi-select-checkbox:checked`);
        
        selectedContainer.innerHTML = '';
        
        if (naCheckbox && naCheckbox.checked) {
          const tag = document.createElement('span');
          tag.className = 'multi-select-tag';
          tag.textContent = naCheckbox.value;
          selectedContainer.appendChild(tag);
        } else if (selectedCheckboxes.length > 0) {
          selectedCheckboxes.forEach(cb => {
            const tag = document.createElement('span');
            tag.className = 'multi-select-tag';
            tag.textContent = cb.value;
            selectedContainer.appendChild(tag);
          });
        } else {
          const placeholder = document.createElement('span');
          placeholder.className = 'multi-select-placeholder';
          placeholder.textContent = '-- Select --';
          selectedContainer.appendChild(placeholder);
        }
      }
      
      // Find the multi-select container
      let container = null;
      const escapedPath = pathStr.replace(/\./g, '_');
      container = document.getElementById(`multiselect_${escapedPath}`);
      
      if (!container) {
        const allContainers = document.querySelectorAll('.multi-select-container');
        for (const cont of allContainers) {
          const firstCheckbox = cont.querySelector('[data-path]');
          if (firstCheckbox && firstCheckbox.dataset.path === pathStr) {
            container = cont;
            break;
          }
        }
      }
      
      if (container) {
        const allCheckboxes = document.querySelectorAll(`[data-path="${pathStr}"].multi-select-checkbox`);
        const naCheckbox = document.getElementById(`${pathStr}_na`);
        
        if (allCheckboxes.length === 0) {
          console.warn(`No multi-select checkboxes found for: ${pathStr}`);
          
          // Still validate the value
          setTimeout(() => {
            if (!isValidValueForField(pathStr, values)) {
              markFieldAsInvalid(pathStr, values);
            }
          }, 100);
          return;
        }
        
        // Clear all selections first
        allCheckboxes.forEach(cb => cb.checked = false);
        if (naCheckbox) naCheckbox.checked = false;
        
        const exclusiveOptions = ['None of the listed options', 'Unknown/Unsure', 'N/A'];
        
        // Handle string value (single selection)
        if (typeof values === 'string') {
          // Check for special values
          if (naCheckbox && naCheckbox.value === values) {
            naCheckbox.checked = true;
          } else if (exclusiveOptions.includes(values)) {
            const matchingCheckbox = Array.from(allCheckboxes).find(cb => cb.value === values);
            if (matchingCheckbox) {
              matchingCheckbox.checked = true;
            } else {
              // Value not in checkbox list
              console.warn(`Value "${values}" not found in checkbox options for ${pathStr}`);
            }
          } else {
            const matchingCheckbox = Array.from(allCheckboxes).find(cb => cb.value === values);
            if (matchingCheckbox) {
              matchingCheckbox.checked = true;
            } else {
              // Value not in checkbox list
              console.warn(`Value "${values}" not found in checkbox options for ${pathStr}`);
            }
          }
        } 
        // Handle array of values (multiple selections)
        else if (Array.isArray(values)) {
          if (values.length > 0) {
            const hasExclusiveOption = values.some(val => exclusiveOptions.includes(val));
            
            if (hasExclusiveOption) {
              // Handle exclusive options (N/A, Unknown, None)
              const exclusiveValue = values.find(val => exclusiveOptions.includes(val));
              if (exclusiveValue === 'N/A' && naCheckbox) {
                naCheckbox.checked = true;
              } else {
                const exclusiveCheckbox = Array.from(allCheckboxes).find(cb => cb.value === exclusiveValue);
                if (exclusiveCheckbox) {
                  exclusiveCheckbox.checked = true;
                } else {
                  console.warn(`Exclusive value "${exclusiveValue}" not found in checkbox options for ${pathStr}`);
                }
              }
            } else {
              // Handle regular multi-select values
              values.forEach(val => {
                const checkbox = Array.from(allCheckboxes).find(cb => cb.value === val);
                if (checkbox) {
                  checkbox.checked = true;
                } else {
                  console.warn(`Value "${val}" not found in checkbox options for ${pathStr}`);
                }
              });
            }
          }
        }
        
        // Update the display
        updateMultiSelectDisplayLocal(container.id, pathStr);
        
        // Validate the selected values (special values are always valid)
        setTimeout(() => {
          // Check if any special values are selected
          const hasSpecialValue = Array.isArray(values) 
            ? values.some(val => exclusiveOptions.includes(val) || val === -9999 || val === -8888)
            : exclusiveOptions.includes(values) || values === -9999 || values === -8888;
          
          if (!hasSpecialValue && !isValidValueForField(pathStr, values)) {
            markFieldAsInvalid(pathStr, values);
          }
        }, 150);
      } else {
        console.warn(`No multi-select container found for: ${pathStr}`);
        
        // Still validate the value
        setTimeout(() => {
          // Check for special values
          const hasSpecialValue = Array.isArray(values)
            ? values.some(val => val === 'N/A' || val === 'Unknown/Unsure' || 
                              val === 'None of the listed options' || 
                              val === -9999 || val === -8888)
            : values === 'N/A' || values === 'Unknown/Unsure' || 
              values === 'None of the listed options' || 
              values === -9999 || values === -8888;
          
          if (!hasSpecialValue && !isValidValueForField(pathStr, values)) {
            markFieldAsInvalid(pathStr, values);
          }
        }, 100);
      }
    }

      function populateArrayOfObjects(pathStr, items) {
      const container = document.getElementById('array_' + pathStr);
      if (!container) {
        console.warn(`Array container not found for: ${pathStr}`);
        return;
      }
      
      const existingItems = container.querySelectorAll('.array-item');
      existingItems.forEach(item => item.remove());
      
      const keys = pathStr.split('.');
      let currentProp = currentSchema.properties;
      
      for (let i = 0; i < keys.length; i++) {
        if (currentProp[keys[i]]) {
          if (currentProp[keys[i]].$ref) {
            currentProp = resolveRef(currentProp[keys[i]].$ref);
            if (i < keys.length - 1) {
              currentProp = currentProp.properties;
            }
          } else if (i === keys.length - 1) {
            currentProp = currentProp[keys[i]];
          } else {
            currentProp = currentProp[keys[i]].properties;
          }
        }
      }
      
      const itemSchema = currentProp.items;
      
      items.forEach((itemData, index) => {
        window.addArrayItem(pathStr, itemSchema);
        
        setTimeout(() => {
          for (const [subKey, subValue] of Object.entries(itemData)) {
            const itemPath = `${pathStr}.${index}.${subKey}`;
            populateSingleField(itemPath, subValue);
          }
        }, 50);
      });
    }

    // ============ CONDITIONAL LOGIC FUNCTIONS ============
    function applyConditionalRules() {
      if (!conditionalRules || Object.keys(conditionalRules).length === 0) {
        return;
      }

      for (const [triggerField, conditions] of Object.entries(conditionalRules)) {
        conditions.forEach(condition => {
          const triggerValue = condition.value;
          const affectedFields = condition.disable_fields || [];
          
          const currentValue = getFieldValue(triggerField);
          const conditionMet = String(currentValue).trim() === String(triggerValue).trim();
          
          affectedFields.forEach(fieldKey => {
            const fieldGroup = document.querySelector(`[data-field-path="${fieldKey}"]`);
            if (!fieldGroup) return;
            
            if (conditionMet) {
              fieldGroup.classList.add('disabled');
              
              if (!fieldGroup.querySelector('.disabled-indicator')) {
                const indicator = document.createElement('div');
                indicator.className = 'disabled-indicator';
                indicator.textContent = `Auto-disabled (based on ${triggerField})`;
                fieldGroup.appendChild(indicator);
              }
              
              setDisabledFieldValue(fieldKey, fieldGroup);
            } else {
              fieldGroup.classList.remove('disabled');
              
              const indicator = fieldGroup.querySelector('.disabled-indicator');
              if (indicator) indicator.remove();
            }
          });
        });
      }
    }

    function getFieldValue(fieldPath) {
      let input = document.querySelector(`select[data-path="${fieldPath}"]`);
      if (input) return input.value;
      
      input = document.querySelector(`input[type="text"][data-path="${fieldPath}"], input[type="email"][data-path="${fieldPath}"]`);
      if (input) return input.value;
      
      input = document.querySelector(`input[type="number"][data-path="${fieldPath}"]`);
      if (input) return input.value ? Number(input.value) : null;
      
      input = document.querySelector(`input[type="checkbox"][data-path="${fieldPath}"]:not(.multi-select-checkbox):not(.na-checkbox)`);
      if (input) return input.checked;
      
      const naCheckbox = document.getElementById(fieldPath + '_na');
      if (naCheckbox && naCheckbox.checked) return naCheckbox.value;
      
      const multiCheckboxes = document.querySelectorAll(`[data-path="${fieldPath}"].multi-select-checkbox:checked`);
      if (multiCheckboxes.length > 0) {
        return Array.from(multiCheckboxes).map(cb => cb.value);
      }

      return null;
    }

  function setDisabledFieldValue(fieldPath, fieldGroup) {
    const fieldType = getFieldTypeFromSchema(fieldPath);
    let defaultValue;
    
    if (fieldType === 'integer' || fieldType === 'number') {
      defaultValue = -2;
    } else if (fieldType === 'date') {
      defaultValue = '1900-01-01';
    } else {
      defaultValue = 'N/A';
    }
    
    const selectInput = fieldGroup.querySelector(`select[data-path="${fieldPath}"]`);
    if (selectInput) {
      let naOption = Array.from(selectInput.options).find(opt => opt.value === defaultValue);
      if (!naOption && defaultValue === 'N/A') {
        naOption = document.createElement('option');
        naOption.value = 'N/A';
        naOption.textContent = 'N/A';
        selectInput.appendChild(naOption);
      }
      selectInput.value = defaultValue;
      return;
    }
    
    const textInput = fieldGroup.querySelector(`input[type="text"][data-path="${fieldPath}"], input[type="email"][data-path="${fieldPath}"]`);
    if (textInput) {
      textInput.value = defaultValue;
      return;
    }
    
    const numberInput = fieldGroup.querySelector(`input[type="number"][data-path="${fieldPath}"]`);
    if (numberInput) {
      numberInput.value = defaultValue;
      return;
    }
    
    const dateInput = fieldGroup.querySelector(`input[type="date"][data-path="${fieldPath}"]`);
    if (dateInput) {
      dateInput.value = defaultValue;
      return;
    }
    
    const multiSelectContainer = fieldGroup.querySelector('.multi-select-container');
    if (multiSelectContainer) {
      const dropdownId = multiSelectContainer.id;
      const path = fieldPath;
      
      const allCheckboxes = document.querySelectorAll(`[data-path="${path}"].multi-select-checkbox`);
      allCheckboxes.forEach(cb => cb.checked = false);
      
      const naCheckbox = document.getElementById(path + '_na');
      if (naCheckbox) {
        // FIX: Check if naCheckbox.value matches defaultValue, if not update it
        if (naCheckbox.value !== defaultValue) {
          naCheckbox.value = defaultValue;
          // Also update the label if it exists
          const naLabel = document.querySelector(`label[for="${path}_na"]`);
          if (naLabel) {
            naLabel.textContent = `${defaultValue} (exclusive)`;
          }
        }
        naCheckbox.checked = true;
      } else {
        // If no NA checkbox exists, create one
        const dropdown = document.getElementById(dropdownId + '_dropdown');
        if (dropdown) {
          const naOption = document.createElement('div');
          naOption.className = 'multi-select-option na-option';
          naOption.innerHTML = `
            <input type="checkbox" 
              id="${path}_na" 
              value="${defaultValue}" 
              data-path="${path}"
              data-dropdown="${dropdownId}"
              class="na-checkbox"
              onchange="handleNAChange('${path}', '${dropdownId}')">
            <label for="${path}_na">${defaultValue} (exclusive)</label>
          `;
          dropdown.appendChild(naOption);
          // Check the new NA checkbox
          setTimeout(() => {
            const newNaCheckbox = document.getElementById(path + '_na');
            if (newNaCheckbox) newNaCheckbox.checked = true;
          }, 10);
        }
      }
      
      updateMultiSelectDisplay(dropdownId, path);
      return;
    }
  }

    function getFieldTypeFromSchema(fieldPath) {
      const keys = fieldPath.split('.');
      let current = currentSchema.properties;
      
      for (let i = 0; i < keys.length; i++) {
        if (!current || !current[keys[i]]) return 'string';
        
        const prop = current[keys[i]];
        
        if (prop.$ref) {
          const resolved = resolveRef(prop.$ref);
          if (i === keys.length - 1) {
            return resolved.type || 'string';
          }
          current = resolved.properties;
        } else if (i === keys.length - 1) {
          return prop.type || 'string';
        } else {
          current = prop.properties;
        }
      }
      
      return 'string';
    }

    // ============ DEPENDENCY MANAGEMENT FUNCTIONS ============
    function initializeDependencies() {
      fieldDependencies = {};
      
      for (const [fieldKey, config] of Object.entries(customChoices)) {
        if (config && config.dependent_values) {
          for (const [dependencyField, valueMap] of Object.entries(config.dependent_values)) {
            if (!fieldDependencies[dependencyField]) {
              fieldDependencies[dependencyField] = [];
            }
            if (!fieldDependencies[dependencyField].includes(fieldKey)) {
              fieldDependencies[dependencyField].push(fieldKey);
            }
          }
        }
      }
      
      console.log('Field dependencies initialized:', fieldDependencies);
    }

    function getDynamicValues(fieldKey) {
      const choiceConfig = customChoices[fieldKey];
      if (!choiceConfig || !choiceConfig.dependent_values) {
        return choiceConfig;
      }
      
      const dependencyValues = {};
      let allDependenciesMet = true;
      
      for (const [dependencyField, valueMap] of Object.entries(choiceConfig.dependent_values)) {
        const currentValue = getFieldValue(dependencyField);
        
        if (currentValue !== null && currentValue !== undefined && currentValue !== '') {
          if (Array.isArray(currentValue)) {
            let matched = false;
            for (const val of currentValue) {
              if (valueMap[val]) {
                dependencyValues[dependencyField] = val;
                matched = true;
                break;
              }
            }
            if (!matched) {
              allDependenciesMet = false;
              break;
            }
          } else {
            if (valueMap[currentValue] !== undefined) {
              dependencyValues[dependencyField] = currentValue;
            } else {
              allDependenciesMet = false;
              break;
            }
          }
        } else {
          allDependenciesMet = false;
          break;
        }
      }
      
      if (allDependenciesMet) {
        let result = { ...choiceConfig };
        
        for (const [dependencyField, depValue] of Object.entries(dependencyValues)) {
          const valueMap = choiceConfig.dependent_values[dependencyField];
          if (valueMap && valueMap[depValue]) {
            result.values = valueMap[depValue];
          }
        }
        
        return result;
      }
      
      return choiceConfig;
    }

    function updateDependentFields(changedFieldPath) {
      console.log(`Updating fields dependent on: ${changedFieldPath}`);
      
      const dependentFields = fieldDependencies[changedFieldPath] || [];
      
      dependentFields.forEach(fieldKey => {
        console.log(`Refreshing dependent field: ${fieldKey}`);
        refreshFieldWithDependencies(fieldKey);
      });
      
      for (const [dependencyField, dependents] of Object.entries(fieldDependencies)) {
        if (dependents.includes(changedFieldPath)) {
          updateDependentFields(dependencyField);
        }
      }
    }

    function refreshFieldWithDependencies(fieldKey) {
      const fieldGroup = document.querySelector(`[data-field-path="${fieldKey}"]`);
      if (!fieldGroup) {
        console.warn(`Field group not found for: ${fieldKey}`);
        return;
      }
      
      const currentValue = getFieldValue(fieldKey);
      console.log(`Current value of ${fieldKey}:`, currentValue);
      
      const keys = fieldKey.split('.');
      let current = currentSchema.properties;
      let prop = null;
      
      for (let i = 0; i < keys.length; i++) {
        if (!current || !current[keys[i]]) {
          console.warn(`Schema path not found: ${fieldKey}`);
          return;
        }
        
        prop = current[keys[i]];
        
        if (prop.$ref) {
          const resolved = resolveRef(prop.$ref);
          if (i === keys.length - 1) {
            prop = resolved;
          } else {
            current = resolved.properties;
          }
        } else if (i === keys.length - 1) {
          // Found the property
        } else {
          current = prop.properties;
        }
      }
      
      if (!prop) return;
      
      const required = getFieldRequirement(fieldKey);
      const newFieldHtml = createField(keys[keys.length - 1], prop, required, keys);
      
      const tempDiv = document.createElement('div');
      tempDiv.innerHTML = newFieldHtml;
      const newFieldGroup = tempDiv.firstElementChild;
      
      fieldGroup.parentNode.replaceChild(newFieldGroup, fieldGroup);
      
      if (currentValue !== null && currentValue !== undefined && currentValue !== '') {
        setTimeout(() => {
          const newValue = getValidValueForField(fieldKey, currentValue);
          if (newValue !== null) {
            populateSingleField(fieldKey, newValue);
          }
        }, 100);
      }
      
      reattachEventListeners();
    }

    function getValidValueForField(fieldKey, value) {
      const choiceConfig = getDynamicValues(fieldKey);
      if (!choiceConfig || !choiceConfig.values) return null;
      
      const validValues = choiceConfig.values;
      
      if (Array.isArray(value)) {
        const validSelections = value.filter(val => validValues.includes(val));
        return validSelections.length > 0 ? validSelections : null;
      } else {
        return validValues.includes(value) ? value : null;
      }
    }

    function getFieldRequirement(fieldKey) {
      const keys = fieldKey.split('.');
      let current = currentSchema;
      
      for (let i = 0; i < keys.length; i++) {
        const key = keys[i];
        
        if (i === 0 && current.required) {
          if (current.required.includes(key)) {
            return true;
          }
        }
        
        if (current.properties && current.properties[key]) {
          const prop = current.properties[key];
          
          if (prop.$ref) {
            current = resolveRef(prop.$ref);
          } else if (i === keys.length - 1) {
            return prop.required ? prop.required.includes(key) : false;
          } else if (prop.properties) {
            current = prop;
          } else {
            return false;
          }
        } else {
          return false;
        }
      }
      
      return false;
    }

    // ============ EVENT LISTENER MANAGEMENT ============
    function attachEventListenersToTab(tabKey) {
      const tabContent = document.getElementById('tab-' + tabKey);
      if (tabContent) {
        const inputs = tabContent.querySelectorAll('input, select, textarea');
        inputs.forEach(input => {
          if (!input.dataset.listenerAttached) {
            input.addEventListener('change', (e) => {
              console.log('Field changed in tab:', tabKey, input.dataset.path, 'Value:', input.value);
              formData = collectFormData();
              setTimeout(() => applyConditionalRules(), 100);
            });
            input.dataset.listenerAttached = 'true';
          }
        });
        
        tabContent.querySelectorAll('.multi-select-container').forEach(container => {
          const dropdownId = container.id;
          const firstCheckbox = container.querySelector('[data-path]');
          if (firstCheckbox) {
            const path = firstCheckbox.dataset.path;
            updateMultiSelectDisplay(dropdownId, path);
          }
        });
      }
      
      setTimeout(() => applyConditionalRules(), 200);
    }
    
    function attachEventListeners() {
      const inputs = document.querySelectorAll('input, select, textarea');
      inputs.forEach(input => {
        if (!input.dataset.listenerAttached) {
          input.addEventListener('change', (e) => {
            console.log('Field changed:', input.dataset.path || input.name, 'Value:', input.value);
            formData = collectFormData();
            setTimeout(() => applyConditionalRules(), 100);
          });
          input.dataset.listenerAttached = 'true';
        }
      });
      
      document.querySelectorAll('.multi-select-container').forEach(container => {
        const dropdownId = container.id;
        const firstCheckbox = container.querySelector('[data-path]');
        if (firstCheckbox) {
          const path = firstCheckbox.dataset.path;
          updateMultiSelectDisplay(dropdownId, path);
        }
      });
      
      setTimeout(() => applyConditionalRules(), 200);
    }

    function setupDependencyListeners() {
      const inputs = document.querySelectorAll('input, select, textarea');
      
      inputs.forEach(input => {
        const originalOnChange = input.onchange;
        
        input.addEventListener('change', function(e) {
          const fieldPath = this.dataset.path || this.name;
          const currentValue = this.type === 'checkbox' ? this.checked : this.value;
          
          console.log(`Field changed: ${fieldPath}, Value:`, currentValue);
          
          // Validate the field after user changes it
          setTimeout(() => {
            validateFieldOnChange(fieldPath, currentValue);
          }, 50);
          
          if (originalOnChange) {
            originalOnChange.call(this, e);
          }
          
          formData = collectFormData();
          updateDependentFields(fieldPath);
          setTimeout(() => applyConditionalRules(), 100);
        });
      });
    }

    function reattachEventListeners() {
      const activeTabBtn = document.querySelector('.tab-btn.active');
      if (activeTabBtn) {
        attachEventListenersToTab(activeTabBtn.dataset.tabKey);
      } else {
        attachEventListeners();
      }
    }

    // ============ UTILITY FUNCTIONS ============
    function updateMultiSelectDisplay(dropdownId, path) {
      const selectedContainer = document.getElementById(dropdownId + '_selected');
      if (!selectedContainer) return;
      
      const naCheckbox = document.getElementById(path + '_na');
      const selectedCheckboxes = document.querySelectorAll(`[data-path="${path}"].multi-select-checkbox:checked`);
      
      selectedContainer.innerHTML = '';
      
      if (naCheckbox && naCheckbox.checked) {
        const tag = document.createElement('span');
        tag.className = 'multi-select-tag';
        tag.textContent = naCheckbox.value;
        selectedContainer.appendChild(tag);
      } else if (selectedCheckboxes.length > 0) {
        selectedCheckboxes.forEach(cb => {
          const tag = document.createElement('span');
          tag.className = 'multi-select-tag';
          tag.textContent = cb.value;
          selectedContainer.appendChild(tag);
        });
      } else {
        const placeholder = document.createElement('span');
        placeholder.className = 'multi-select-placeholder';
        placeholder.textContent = '-- Select --';
        selectedContainer.appendChild(placeholder);
      }
    }

    // ===== new error handling ====== ASHOK
    // ============ INVALID DATA VALIDATION FUNCTIONS ============
    let invalidFields = new Map(); // Map to track invalid fields: path -> {loadedValue, validOptions}

    /**
     * Validates if a value is valid for a given field based on choices.json
     */
    function isValidValueForField(fieldPath, value) {
      // Special values that are always valid
      const specialStringValues = ['N/A', 'Unknown/Unsure', 'None of the listed options'];
      const specialNumericValues = [-9999, -8888, '-9999', '-8888'];
      
      // Check for special values first
      if (Array.isArray(value)) {
        // For arrays, check each value
        const allSpecial = value.every(val => 
          specialStringValues.includes(val) || 
          specialNumericValues.includes(val)
        );
        if (allSpecial) return true;
        
        // Check if any value is special (mixed array)
        const hasSpecial = value.some(val => 
          specialStringValues.includes(val) || 
          specialNumericValues.includes(val)
        );
      } else {
        // Single value
        if (specialStringValues.includes(value) || specialNumericValues.includes(value)) {
          return true; // Special values are always valid
        }
      }
      
      // Get the choice configuration for this field
      const choiceConfig = getDynamicValues(fieldPath);
      
      if (!choiceConfig || !choiceConfig.values) {
        // If no choices defined, all values are valid
        return true;
      }
      
      const validValues = choiceConfig.values;
      
      // Handle multi-select values (arrays)
      if (Array.isArray(value)) {
        // Filter out special values that we've already handled
        const nonSpecialValues = value.filter(val => 
          !specialStringValues.includes(val) && !specialNumericValues.includes(val)
        );
        
        if (nonSpecialValues.length === 0) {
          return true; // All values were special
        }
        
        // For multi-select, all non-special values must be in the valid list
        return nonSpecialValues.every(val => {
          // Check if value is directly in the list
          if (validValues.includes(val)) {
            return true;
          }
          
          // Check for numeric range values like "1-50"
          if (typeof val === 'number' || !isNaN(val)) {
            const numVal = Number(val);
            return validValues.some(validVal => {
              if (typeof validVal === 'string' && validVal.includes('-')) {
                const rangeMatch = validVal.match(/^(\d+)-(\d+)$/);
                if (rangeMatch) {
                  const min = parseInt(rangeMatch[1]);
                  const max = parseInt(rangeMatch[2]);
                  return numVal >= min && numVal <= max;
                }
              }
              return false;
            });
          }
          
          return false;
        });
      }
      
      // Handle single-select values
      
      // Check if value is directly in the list
      if (validValues.includes(value)) {
        return true;
      }
      
      // Check for numeric range values like "1-50"
      if (typeof value === 'number' || !isNaN(value)) {
        const numVal = Number(value);
        return validValues.some(validVal => {
          if (typeof validVal === 'string' && validVal.includes('-')) {
            const rangeMatch = validVal.match(/^(\d+)-(\d+)$/);
            if (rangeMatch) {
              const min = parseInt(rangeMatch[1]);
              const max = parseInt(rangeMatch[2]);
              return numVal >= min && numVal <= max;
            }
          }
          return Number(validVal) === numVal;
        });
      }
      
      // For string values that might be in the list
      return validValues.includes(value.toString());
    }

    /**
     * Marks a field as invalid and stores the invalid value
     */
    function markFieldAsInvalid(fieldPath, loadedValue) {
      // Get the field element
      let fieldElement = document.querySelector(`[data-path="${fieldPath}"]`);
      
      if (!fieldElement) {
        // For nested fields in multi-select containers
        const multiSelectContainer = document.querySelector(`[data-field-path="${fieldPath}"] .multi-select-container`);
        if (multiSelectContainer) {
          fieldElement = multiSelectContainer;
        } else {
          // Try other input types
          fieldElement = document.querySelector(`select[data-path="${fieldPath}"], 
                                                input[data-path="${fieldPath}"], 
                                                textarea[data-path="${fieldPath}"]`);
        }
      }
      
      if (!fieldElement) {
        console.warn(`Could not find element for invalid field: ${fieldPath}`);
        return;
      }
      
      // Add invalid class to the element
      fieldElement.classList.add('invalid-data');
      
      // Store the invalid data in our map
      const choiceConfig = getDynamicValues(fieldPath);
      invalidFields.set(fieldPath, {
        loadedValue: loadedValue,
        validOptions: choiceConfig?.values || [],
        element: fieldElement
      });
      
      // Add tooltip for mouse hover
      fieldElement.addEventListener('mouseenter', showInvalidTooltip);
      fieldElement.addEventListener('mouseleave', hideInvalidTooltip);
      
      console.log(`Marked field as invalid: ${fieldPath}`, loadedValue);
    }

    /**
     * Clears invalid status from a field
     */
    function clearFieldInvalidStatus(fieldPath) {
      const fieldInfo = invalidFields.get(fieldPath);
      if (fieldInfo && fieldInfo.element) {
        fieldInfo.element.classList.remove('invalid-data');
        fieldInfo.element.removeEventListener('mouseenter', showInvalidTooltip);
        fieldInfo.element.removeEventListener('mouseleave', hideInvalidTooltip);
      }
      invalidFields.delete(fieldPath);
      
      // Update the invalid fields summary
      updateInvalidFieldsSummary();
    }

    /**
     * Shows tooltip for invalid fields
     */
    function showInvalidTooltip(event) {
      const element = event.currentTarget;
      const fieldPath = element.dataset?.path || 
                        element.closest('[data-field-path]')?.dataset?.fieldPath;
      
      if (!fieldPath) return;
      
      const fieldInfo = invalidFields.get(fieldPath);
      if (!fieldInfo) return;
      
      // Create or update tooltip
      let tooltip = element.querySelector('.invalid-tooltip');
      if (!tooltip) {
        tooltip = document.createElement('div');
        tooltip.className = 'invalid-tooltip';
        element.appendChild(tooltip);
      }
      
      let message = `Invalid value: "${fieldInfo.loadedValue}"\n`;
      if (fieldInfo.validOptions.length > 0) {
        message += `Valid options: ${fieldInfo.validOptions.slice(0, 3).join(', ')}`;
        if (fieldInfo.validOptions.length > 3) {
          message += `... and ${fieldInfo.validOptions.length - 3} more`;
        }
      }
      
      tooltip.textContent = message;
      tooltip.style.display = 'block';
      
      // Position tooltip
      const rect = element.getBoundingClientRect();
      tooltip.style.top = `${rect.top - tooltip.offsetHeight - 5}px`;
      tooltip.style.left = `${rect.left}px`;
    }

    /**
     * Hides tooltip for invalid fields
     */
    function hideInvalidTooltip(event) {
      const element = event.currentTarget;
      const tooltip = element.querySelector('.invalid-tooltip');
      if (tooltip) {
        tooltip.style.display = 'none';
      }
    }

    /**
     * Creates and displays a summary of all invalid fields
     */
    function updateInvalidFieldsSummary() {
      // Remove existing summary if any
      const existingSummary = document.getElementById('invalid-fields-summary');
      if (existingSummary) {
        existingSummary.remove();
      }
      
      // If no invalid fields, don't show summary
      if (invalidFields.size === 0) {
        return;
      }
      
      // Create summary container
      const summary = document.createElement('div');
      summary.id = 'invalid-fields-summary';
      summary.className = 'invalid-fields-summary';
      
      let summaryHtml = `
        <button class="close-summary" onclick="this.parentElement.remove()">√ó</button>
        <h3>‚ö†Ô∏è Invalid Data Found (${invalidFields.size} field${invalidFields.size > 1 ? 's' : ''})</h3>
        <p>The following fields contain values not in the allowed list:</p>
        <ul>
      `;
      
      // Add each invalid field to the list
      invalidFields.forEach((fieldInfo, fieldPath) => {
        const displayPath = fieldPath.split('.').pop(); // Show only last part of path
        const loadedValue = Array.isArray(fieldInfo.loadedValue) 
          ? fieldInfo.loadedValue.join(', ') 
          : fieldInfo.loadedValue;
        
        summaryHtml += `
          <li onclick="scrollToInvalidField('${fieldPath}')">
            <strong>${displayPath}:</strong> "${loadedValue}"
          </li>
        `;
      });
      
      summaryHtml += `
        </ul>
        <p style="margin-top: 10px; font-size: 12px;">
          Click on a field above to scroll to it. Select a valid value from the dropdown to fix.
        </p>
      `;
      
      summary.innerHTML = summaryHtml;
      
      // Insert summary at the top of the form
      const form = document.getElementById('editor-form') || 
                  document.querySelector('.tab-content.active') || 
                  document.querySelector('.tabs-container');
      if (form) {
        form.parentNode.insertBefore(summary, form);
      }
    }

    /**
     * Scrolls to an invalid field when clicked in the summary
     */
    function scrollToInvalidField(fieldPath) {
      const fieldElement = document.querySelector(`[data-field-path="${fieldPath}"],
                                                  select[data-path="${fieldPath}"],
                                                  input[data-path="${fieldPath}"],
                                                  textarea[data-path="${fieldPath}"]`);
      
      if (fieldElement) {
        // Scroll to the field
        fieldElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        // Highlight with a temporary animation
        fieldElement.style.transition = 'all 0.3s';
        fieldElement.style.boxShadow = '0 0 0 3px rgba(220, 53, 69, 0.3)';
        
        setTimeout(() => {
          fieldElement.style.boxShadow = '';
        }, 2000);
        
        // Focus the field if it's an input
        const inputElement = fieldElement.querySelector('input, select, textarea') || fieldElement;
        if (inputElement.focus) {
          inputElement.focus();
        }
      }
    }

    /**
     * Validates all fields after data is loaded
     */
    function validateLoadedData(data, parentPath = []) {
      invalidFields.clear(); // Clear previous invalid fields
      
      for (const [key, value] of Object.entries(data)) {
        const currentPath = [...parentPath, key];
        const pathStr = currentPath.join('.');
        
        if (value !== null && typeof value === 'object' && !Array.isArray(value)) {
          // Recursively validate nested objects
          validateLoadedData(value, currentPath);
        } else if (value !== null && value !== undefined && value !== '') {
          // Validate this field's value
          if (!isValidValueForField(pathStr, value)) {
            console.log(`Invalid value found: ${pathStr} =`, value);
            markFieldAsInvalid(pathStr, value);
          }
        }
      }
      
      // Update the invalid fields summary
      updateInvalidFieldsSummary();
    }

    /**
     * Validates a single field when user changes it
     */
    function validateFieldOnChange(fieldPath, currentValue) {
      if (!isValidValueForField(fieldPath, currentValue)) {
        // Field is still invalid
        if (!invalidFields.has(fieldPath)) {
          markFieldAsInvalid(fieldPath, currentValue);
        }
      } else {
        // Field is now valid, clear invalid status
        clearFieldInvalidStatus(fieldPath);
      }
    }
    // ===== END error handling ====== ASHOK

    // ============ WINDOW FUNCTIONS (Global scope) ============
    window.toggleNested = function(header) {
      header.classList.toggle('collapsed');
      header.nextElementSibling.nextElementSibling.classList.toggle('collapsed');
    };

    window.addArrayItem = function(arrayPath, itemSchema) {
      itemSchema = typeof itemSchema === 'string' ? JSON.parse(itemSchema.replace(/&quot;/g, '"')) : itemSchema;
      
      if (itemSchema.$ref) {
        itemSchema = resolveRef(itemSchema.$ref);
      }
      
      const container = document.getElementById('array_' + arrayPath);
      const items = container.querySelectorAll('.array-item');
      const index = items.length;
      
      const properties = itemSchema.properties || {};
      const required = itemSchema.required || [];
      
      let fieldsHtml = '';
      for (const [subKey, subProp] of Object.entries(properties)) {
        const isSubRequired = required.includes(subKey);
        fieldsHtml += createField(subKey, subProp, isSubRequired, [...arrayPath.split('.'), index, subKey]);
      }
      
      const itemDiv = document.createElement('div');
      itemDiv.className = 'array-item';
      itemDiv.innerHTML = `
        <div class="array-item-header">
          <span class="array-item-title">Item ${index + 1}</span>
          <button class="remove-item-btn" onclick="removeArrayItem(this)">Remove</button>
        </div>
        ${fieldsHtml}
      `;
      
      container.insertBefore(itemDiv, container.querySelector('.array-controls'));
      
      const activeTabBtn = document.querySelector('.tab-btn.active');
      if (activeTabBtn) {
        attachEventListenersToTab(activeTabBtn.dataset.tabKey);
      } else {
        attachEventListeners();
      }
    };

    window.removeArrayItem = function(btn) {
      const item = btn.closest('.array-item');
      item.remove();
      const container = item.parentElement;
      const items = container.querySelectorAll('.array-item');
      items.forEach((item, idx) => {
        item.querySelector('.array-item-title').textContent = 'Item ' + (idx + 1);
      });
    };

    window.handleMultiSelectChange = function(path, dropdownId) {
      const changedCheckbox = event.target;
      const changedValue = changedCheckbox.value;
      
      const exclusiveOptions = ['Unknown/Unsure', 'None of the listed options', 'N/A'];
      
      if (exclusiveOptions.includes(changedValue) && changedCheckbox.checked) {
        const allCheckboxes = document.querySelectorAll(`[data-path="${path}"].multi-select-checkbox, #${path}_na`);
        allCheckboxes.forEach(cb => {
          if (cb !== changedCheckbox) {
            cb.checked = false;
          }
        });
      } else if (changedCheckbox.checked) {
        const allCheckboxes = document.querySelectorAll(`[data-path="${path}"].multi-select-checkbox, #${path}_na`);
        allCheckboxes.forEach(cb => {
          if (exclusiveOptions.includes(cb.value)) {
            cb.checked = false;
          }
        });
      }
      
      // Validate after change
      setTimeout(() => {
        const currentValue = getFieldValue(path);
        validateFieldOnChange(path, currentValue);
      }, 50);

      updateMultiSelectDisplay(dropdownId, path);
    };

    window.handleNAChange = function(path, dropdownId) {
      const naCheckbox = document.getElementById(path + '_na');

      if (naCheckbox && naCheckbox.checked) {
        const multiSelectCheckboxes = document.querySelectorAll(`[data-path="${path}"].multi-select-checkbox`);
        multiSelectCheckboxes.forEach(cb => cb.checked = false);
      }
      // Validate after change
      setTimeout(() => {
        const currentValue = getFieldValue(path);
        validateFieldOnChange(path, currentValue);
      }, 50);
      
      updateMultiSelectDisplay(dropdownId, path);
    };

    window.toggleMultiSelectDropdown = function(dropdownId) {
      const dropdown = document.getElementById(dropdownId + '_dropdown');
      if (dropdown) {
        const isOpen = dropdown.classList.contains('open');
        
        document.querySelectorAll('.multi-select-dropdown').forEach(dd => {
          dd.classList.remove('open');
        });
        
        if (!isOpen) {
          dropdown.classList.add('open');
        }
      }
    };

    // ============ GLOBAL EVENT LISTENERS ============
    document.addEventListener('click', function(event) {
      if (!event.target.closest('.multi-select-container')) {
        document.querySelectorAll('.multi-select-dropdown').forEach(dd => {
          dd.classList.remove('open');
        });
      }
    });
  </script>
</body>
</html>